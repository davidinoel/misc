Assumption:
The entirety of the crypto protocol and cipher suite being used to create, establish, and maintain the connection is secure, and the client and server are well-behaved, secure, and trusted as well.

Problem & Background:
For as long as a I can remember, vulnerabilities in TLS's ability to hide server and end-user interactions have been well documented relating to the fact that page sizes of public websites are known, or easily discoverable, and that using that knowledge and observing the traffic, anyone on the line can fairly easily determine what a user is accessing on a particular website.

To expand on that, essentially any encrypted traffic may be subject to such eavesdropping. Server to server/database, server to end-user applications, etc. If enough information about the applications, servers, databases, schemas, or whatever is being transmitted is known, while there *may* not be sufficient leakage to give observers knowledge of precisely what is being communicated, enough information may be leaked out to allow adversaries to gain a picture of what is going on behind the scenes.

The best method of preventing encrypted data sent between parties to be known by an observer looking only at the network traffic as it passes by is to allocate a constant bitrate between the server and client, to fill it with a constant stream of data (garbage/noise, or actual data), and to inject the useful data into the stream in a seamless manner as needed.

While that can be a viable option in some situations, unfortunately, in many others it is quite impractical (large-scale web applications, for example), as you or the server you're connected to can't realistically allocate an entire N Kbps pipe to you and every other user connected to it. Nor would this necessarily be a desirable solution, as internet providers have recently begun to transition to capping data-usage, similar to cellular providers.

Solution:
An alternative that may serve as a sort of middle-ground between the two is, assuming compression is not a concern (which at the time of initially writing this there were a few issues with), utilizing compression and randomly changing compression ratio/level along with randomizing the interval between the changing of the ratio.
